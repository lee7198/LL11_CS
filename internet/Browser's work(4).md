# 브라우저의 동작 💻 (4)

- [브라우저의 동작(1)](https://github.com/lee7198/LL11_CS/blob/main/internet/Browser's%20work(1).md)
- [브라우저의 동작(2)](https://github.com/lee7198/LL11_CS/blob/main/internet/Browser's%20work(2).md)
- [브라우저의 동작(3)](https://github.com/lee7198/LL11_CS/blob/main/internet/Browser's%20work(3).md)

## 배치 (positioning)

렌더러가 생성되어 트리에 추가될 때 크기와 위치 정보는 없는데 이런 값을 계산하는 것을 배치 또는 리플로라고 부른다.

HTML은 흐름 기반의 배치 모델을 사용하는데 이것은 보통 단일 경로를 통해 크기와 위치 정보를 계산할 수 있습니다. 일반적으로 **흐름 속**에서 나중에 등장하는 요소는 앞서 등장한 요소의 위치와 크기에 영향을 미치지 않기 때문에 배치는 왼쪽에서 오른쪽으로 또는 위에서 아래로 흐른다. 단, 표는 크기와 위치를 계산하기 위해 하나 이상의 경로를 필요로 하기 때문에 예외가 됩니다.

좌표계는 기준점으로부터 상대적인 위치로 결정하는데, x축과 y축 좌표를 사용합니다.

배치는 반복괴며 HTML 문서의 ``<HTML>`` 요소에 해당하는 최상위 렌더러에서 시작합니다. 배치는 프레임 계층의 일부 또는 전부를 통해 반복되고 각 렌더러에 필요한 크기와 위치 정보를 계산합니다.

최상위 렌더러의 위치는 (0, 0)이고 브라우저의 창의 보이는 영역에 해당하는 뷰포트 만큼의 면적을 갖습니다.

모든 렌더러는 **배치(position)** 또는 **리플로(reflow)** 메서드를 갖는데 각 렌더러는 배치해야 할 자식의 배치 메소드를 불러옵니다.

### 더티 비트 체제
소소한 변경 때문에 전체를 다시 배치하지 않기 위해 브라우저는 **더치 비트** 체제를 사용합니다. 렌더러는 다시 배치할 필요가 있는 변경 요소 또는 추가된 것과 그 자식을 **더티**라고 표시합니다.

> **더티**와 **자식이 더티** 이렇게 두 가지 플래그가 있습니다. 자식이 더티하다는 것은 본인은 괜찮지만 자식 가운데 적어도 하나를 재배치 해야할 필요가 있다는 의미입니다.

### 전역 배치와 점증 배치
배치는 렌더러 트리 전체에서 일어날 수 있는데 이것을 **전역** 배치라 하고 다음과 같은 경우에 발생합니다.

1. 글꼴 크기 변경과 같이 모든 렌더러에 영향을 주는 전역 스타일 변경.
2. 화면 크기 변경에 의한 결과

배치는 더티 렌더러가 배치되는 경우에만 점증되는데 추가적인 배치가 필요하기 때문에 약간의 손실이 발생할 수 있다.

점증 배치는 렌더러가 더티일 때 비동기적으로 일어납니다. 예를 들어 네트워크로 부터 추가 내용을 받아 DOM 트리에 더해진 다음 새로운 렌더러가 렌더 트리에 붙을 때입니다.

![](https://velog.velcdn.com/images/lee7198/post/9580563d-3fa6-4c31-8e44-7ee978837d4d/image.png)

	오직 더티 렌더러와 그 자식만 배치됩니다.
    
### 비동기 배치와 동기 배치
점증 배치는 비동기로 실행합니다. firefox는 점증 배치를 위해 **reflow 명령**을 쌓아 놓고 스케줄러는 이 명령을 한꺼번에 실행합니다. webkit도 점증 배치를 실행하는 타이머가 있는데 트리를 탐색하여 **dirty** 렌더러를 배치합니다.

**ofsetHeight** 같은 스타일 정보를 요청하는 스크립트는 동기적으로 점증 배치를 실행합니다.

전역 배치는 보통 동지적으로 실행합니다.
때론 배치치는 스크롤 위치 변화와 같은 일부 속성들 때문에 초기 배치 이후 콜백으로 실행합니다.

### 최적화
배치가 **크기 변경** 또는 렌더러 위치 변화 때문에 실행되는 경우 렌더러의 크기는 다시 계산하지 않고 캐시로부터 가져온다.
> 어떤 경우는 하위 트리만 수정이되고 최상위로부터 배치가 시작되지 않는 경우도 있습니다. 이런 경우는 입력 필드에 텍스트를 입력하는 경우와 같이 변화 범위가 한정적이어서 주변에 영향을 미치지 않을 때 발생합니다. 만약 입력 필드 바깥쪽에 텍스트가 입력되는 경우라면 배치는 최상단으로부터 시작될 것입니다.

#### 배치 과정
1. 부모 렌더러가 자신의 너비를 결정
2. 부모가 자식을 검토
	a. 자식 렌더러를 배치 (자식의 x, y)
    b. (부모와 자식이 dirty하거나 전역 배치 상태이거나 등) 필요하다면 자식 배치를 호출하여 자식의 높이를 계산
3. 부모는 자식의 누적된 높이와 margin, padding을 사용하여 자신의 높이를 설정. 이 값은 부모 렌더러의 부모가 사용
4. dirty 비트 플래그를 제거

#### 너비 계산
렌더러의 너비는 포함하는 블록의 너비와 렌더러의 너비의 margin, border를 이용하여 계산됨
![](https://velog.velcdn.com/images/lee7198/post/bb3b711d-126c-4dee-96ca-dd76a85f7c53/image.png)

예를 들어 다음과 같은 div 요소의 너비를 확인합니다.

``` html
<div style="width:30%"></div>
```

webkit은 다음(RenderBox 클래스의 calcWidth 매서드)과 같이 계산할 것입니다.
- 컨테이너의 너비는 컨테이너 availableWidth과 0 사이의 최대값입니다. 이 경우 다음과 같이 계산된 contentWidth입니다.
	``clientWidth()`` - ``paddingLeft()`` - ``paddingRight()``
    > **clientWidth**와 **clientHeight**는 객체의 테두리와 스크롤바를 제외한 내부 영역을 의미합니다.
- 요소의 너비는 **width** 스타일 속성의 값이다. 이 컨테이너 너비는 백분률 값은 절대 값으로 변화될 것입니다.
- 좌우측 테두리(border)와 여백(padding) 값이 추가됩니다.

여기까지가 **선언된 너비**의 계산입니다. 이후 최소 너비와 최대 너비를 계산해야 합니다.

선언된 너비가 최대 너비보다 크다면 최대 너비가 사용됩니다. 미리 획득한 너비가 최소 너비(깨지지 않는 가장 작은 단위)보다 작으면 최소 너비가 사용됩니다.

배치한 필요가 있지만 너비가 고정된 경우 값은 캐시에 저장됩니다.

#### 줄 바꿈
렌더러가 배치되는 동안 줄을 바꿀 필요가 있을 때 배치는 중단되고 줄 바꿀 필요가 있음을 부모게게 전달합니다. 부모는 추가 렌더러를 생성하고 배치를 호출합니다.

## 그리기 (painting)

그리기 단계에서는 화면에 내용을 표시하기 위한 렌더 트리가 탐색되고 렌더러의 **paint** 메서드가 호출됩니다. 그리기는 UI 기반의 구성 요소를 사용하게 됩니다.

#### Gloval and Incremental
그리기는 배치와 마찬가지로 전역 또는 점증 방식으로 수행한다. 점증 그리기에서 일부 렌더러는 전체 트리에 영향을 주지 않는 방식으로 변경됩니다. 변경된 렌더러는 화면 위의 사각형을 무효화 하는데 운영체제는 이것을 **dirty region**으로 보고 **paint** 이벤트를 발생시켜, 운영체제는 효과적인 병합의 방법으로 처리하게 됩니다. 크롬은 렌더러가 별도의 처리 과정이기 때문에 조금 더 복잡합니다. 크롬은 운영체제의 동작을 어느 정도 모방합니다. 프레젠테이션은 이런 이벤트에 귀 기울이고 렌더 최상위로 메세지를 전달합니다. 그렇게 트리는 적절한 렌더러를 탐색하게되고 스스로(자식과 함께) 다시 그려집니다.

#### 그리는 순서
실제 요소가 stacking contexts에 쌓이는 순서입니다. _(CSS2)_

1. background color
2. background image
3. border
4. children
5. outline

## 동적 변경
브라우저는 변경에 대해 가능한 최소한의 동작으로 반응하려합니다. 그렇기에 요소의 색상이 바뀌면 해당 요소의 repainting만 발생합니다. 요소의 위치가 변경되면 요소의 자식 그리고 형제의 repainting과 재배치가 발생합니다. DOM 노드를 추가하면 노드의 **repainting**과 **repositioning**이 방생합니다. **HTML** 요소의 글꼴 크기를 변경하는 것과 같은 큰 변경은 캐시를 무효화하고 트리 전체의 positioning과 repainting이 발생합니다.

## 렌더링 엔진의 스레드
렌더링 엔진은 통신을 제외한 거의 모든 경우에 단일 스레드로 동작합니다. 

통신은 몇 개의 병렬 스레드에 의해 진행될 수 있는데 병렬 연결의 수는 2개에서 6개로 제한됩니다.

#### 이벤트 순환
브라우저의 주요 스레드는 이벤트 순환으로 처리 과정을 유지하기 위해 무한 순환됩니다. 배치와 그리기 같은 이벤트를 위해 대기하고 이벤트를 처리합니다.


### 참고 자료
[브라우저는 어떻게 동작하는가?, naver D2](https://d2.naver.com/helloworld/59361)
