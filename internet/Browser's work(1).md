# 브라우저의 동작 💻 (1)
- [브라우저의 동작(2)](https://github.com/lee7198/LL11_CS/blob/main/internet/Browser's%20work(2).md)
- [브라우저의 동작(3)](https://github.com/lee7198/LL11_CS/blob/main/internet/Browser's%20work(3).md)

브라우저는 모든 웹 사이트에서 중요한 역할을 맡습니다. 어플리케이션 렌더링 부터 작동 방식까지 모든 것이 브라우저와 관련된 기능에 따라 달라집니다. ***크로스 브라우저 호환성 테스트*** 를 통해 원할한 사용자 경험을 제공하려면 브라우저 렌더링 엔진의 역할을 제대로 이해하는것이 중요합니다.

## 브라우저의 주요 기능

브라우저의 주요 기능은 사용자가 선택한 자원을 서버에 요청하고 브라우저에 표시하는 것이다. 자원은 보통 HTML 문서이지만, PDF나 이미지 또는 다른 형태일 수 있다. 자원의 주소는 URI(Uniform Resource Identifier)에 의해 정해진다.

브라우저 엔진의 역할에 대해 알아보기 전에, 간단하게 웹 브라우저 구조에대해 확인해봅시다.

## 웹 브라우저의 구조


브라우저는 FrontEnd 와 BackEnd로 구성되어 있습니다. FrontEnd가 웹 페이지를 브라우저에 확실하게 보여주기위함이지만, BackEnd는 요청을 처리하는 전달자의 역할입니다. 이것의 다른 구성요소들은 원할한 웹 경험을 제공하기 위해 조화롭게 작동합니다.

![](https://velog.velcdn.com/images/lee7198/post/6e5b8998-f15e-4363-a67d-68307141f827/image.png)

## 브라우저의 구성요소


웹 브라우저는 7가지 컴포넌트로 구성되어있습니다.

### User Interface

최종 유저(실 사용자)는 UI를 통해 웹 페이지에서 사용 가능한 모든 시각적 요소들과 상호 작용할 수 있습니다. 요소들에는 주소창, 홈 버튼, 다음 버튼 등 모든 요소가 포함되어 있으며, 사용자가 요청한 웹 페이지를 가져오고 보여줍니다.

### Browser Engine

브라우저 엔진은 모든 웹 브라우저에서 ***핵심적***인 구성요소입니다. 브라우저 엔진은 ```user Interface```와 ```Rendering engine```의 사이에서 중개해주는 역할을 맡고 있습니다. UI에서 받은 입력에 따라 렌더링 엔진의 쿼리를 처리합니다.

### Rendering Engine

이름 그대로, 렌더링 엔진은 유저가 요청한 웹페이지를 화면에 렌더링합니다. ```HTML``` 또는 ```XML``` 문서를 CSS를 사용하여 스타일하거나 이미지와 함께 해석됩니다. 그리고 최종적으로 레이아웃을 생성하여 UI에 표시합니다.

> 모든 브라우저에는 고유한 렌더링 엔진이 있습니다. 
> 
> ex: chrome과 opera: blink, IE: trident, firefox: gecko, safari: webkit

### Networking

이 요소는 ```FTP``` 나 ```HTTP```와 같은 표준 프로토콜을 사용하여 네트워크 호출을 관리합니다. 그리고 통신과 관련된 보안 문제를 처리합니다.

### JavaScript Interperter

이 요소 또한 이름 그대로, 웹 사이트에 탑재되어 있는 ```JavaScript 코드``` 를 분석하고 실핼하는 역할을 맡습니다. 해석된 결과가 생성되면 렌더링 엔진에 의해 UI에 표시합니다.

### UI BackEnd

이 요소는 운영체제의 아래에 있는 UI 메소드를 사용합니다. 기본 위젯(윈도우 창과 콤보박스 등)을 그리는데 사용됩니다.

### Data Storage / Persistence

브라우저는 ```쿠키``` 와 같은 다양한 종류의 데이터를 저장할 local 공간이 필요합니다. 따라서 브라우저는 WebSQL, IndexedDB, FileSystem 등과 같은 데이터 저장 메커니즘과 호환되어야 합니다.

## 렌더링 엔진과 동작 과정

사용자가 특정 문서를 요청하면, 렌더링 엔진은 요청 문서를 가져오기 시작할 것입니다. 이 작업은 네트워크 계층에 의해 수행됩니다. 렌더링 엔진은 네트워킹 계층에서 8kb(보통 이 속도)로 특정 문서의 내용을 수신하기 시작합니다. 아래의 그림은 렌더링 엔진의 흐름을 나타낸것 입니다.

![](https://user-images.githubusercontent.com/68184254/219853705-15f33ef4-6586-4046-a8b8-f60d806e033a.png)


다음 설명과 함꼐
1. 요청된 HTML 페이지는 외부 CSS 파일과 스타일 요소를 포함하여 렌더링 엔진이 분석합니다. HTML 요소는 DOM 요소로 변환되어 ```content tree``` 또는 ```DOM tree```를 형성합니다.
2. 동시에, 브라우저는***렌더 트리***도 생성합니다. 이 트리는 스타일 정보들과 보여줄 순서를 정의한 지침이 포함되어 있습니다. 이를 통해 렌더 트리는 콘텐츠가 원하는 순서로 표시되도록 합니다.
3. 또한 렌더 트리는 ***레이아웃 프로세스*** 를 거치게되는데, 렌더 트리가  생성될 때에 위치 또는 크기 값이 지정되지 않습니다. 원하는 위치를 정하기 위한 값을 계산하는 전체 프로세스를 ***레이아웃 프로세스*** 라고 합니다.
4. 마지막으로 화면에 그려질 때, 여기서 렌더트리는 탐색을 합니다. 그리고 UI BackEnd 계층을 사용하여 화면의 각 노드에 그리는 렌더러의 ***painter()*** 메소드를 호출합니다.

> 앞써 말한대로 웹 브라우저에는 각기 다양한 렌더링 엔진이 존재합니다. 따라서 개발자는 크로스 브라우저 호환성을 고려하여 개발해야합니다.

### 동작 과정의 예

![](https://velog.velcdn.com/images/lee7198/post/09c46a99-498c-40bc-b176-9ad1cce3fdbe/image.png)
웹킷 동작 과정

![](https://velog.velcdn.com/images/lee7198/post/69511a68-6f51-4c5c-990a-d063512c418f/image.png)
모질라의 게코 렌더링 엔진 동작 과정

게코 렌더링 엔진의 예로써 시각적으로 처리되는 렌더 트리를 ***frame tree*** 라고 부르고 각 요소를 frame이라고 하는데, 웹킷은 ***rander object*** 로 구성되어 있는 ***rander tree*** 라는 용어를 사용한다. webkit은 요소를 배치하는데 ```layout``` 라는 용어를 사용하지만 게코는 ```reflow``` 라고 부릅니다. ***attachment*** 는 webkit이 렌더 트리를 생성하기 위해 DOM 노드와 시각 정보를 연결하는 과정이다. 게코는 HTML과 DOM 트리 사이에 ***content sink*** 라고 부르는 과정을 두는데, 이는 DOM 요소를 생성하는 공정으로 webkit과 비교하여 의미있는 차이점이라고 보지는 않는다.
